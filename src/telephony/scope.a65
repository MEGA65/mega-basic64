
         .org $9800

	 ; Disable interrupts
	 sei

         ; mega65 knock
         lda #$47
         sta $d02f
         lda #$53
         sta $d02f

	 lda #0
	 sta $d021
	 sta $d020
	 
	 ; 50MHz
	 lda #65
	 sta $0

	 ; set CPU port DDR
	 lda #$37
	 sta $0

entry:

         jsr bitmapmode
	 jsr clearcolour
         jsr clearscreen

         ldx #0
loop:

waitingforflyback:
	lda #$ff
	cmp $d012
	bne waitingforflyback

	jsr clearscreen

	ldx #0
drawloop:
	lda previoussamples,x
	tay
	jsr plotpixel

	lda previoussamples2,x
	tay
	jsr plotpixel

	dex
	bne drawloop

	; Then read 256 samples
	ldx #$00
nextsample:
	lda $d012
wait:	cmp $d012
	beq wait

	; select cell modem1 audio in
        lda #$02
        sta $d6f4
        ; get msb of audio sample

	; shift it left a few bits
        lda $d6fc
	sta samplelo
	lda $d6fd
	sta samplehi

	asl samplelo
	rol samplehi

	asl samplelo
	rol samplehi

        lda samplehi
	clc
	adc #40
	sta previoussamples2,x

        ; select microphone audio
        lda #$0a
        sta $d6f4

	; shift it left a few bits
        lda $d6fc
	sta samplelo
	lda $d6fd
	sta samplehi

	asl samplelo
	rol samplehi

	asl samplelo
	rol samplehi

	lda samplehi
	clc
	adc #$80

	sta previoussamples,x

	inx
	bne nextsample
	
	jmp loop

plotpixel:
         ; use $fd and $fe as 16-bit
         ; pointer.

         stx savex
         sty savey

	 jsr calculatepixeladdr

	 lda #$36
	 sta $01

         ; work out bit of byte to set
         lda savex
         and #7
         tax
         lda bits,x
         ldy #0

	 ; set bit in byte
         ora ($fd),y
         sta ($fd),y

	 lda #$37
	 sta $01


         ldx savex
         ldy savey

         rts



calculatepixeladdr:
         ; reset our pointer to $0020, to centre in the frame
         lda #<$0020
         sta $fd

         ; calculate address of pixel

         ; work out 256*int(y/8)
         lda savey
         lsr
         lsr
         lsr
         sta $fe

         ; work out 64*int(y/8), and add
         ; it.
         lda savey
         asl
         asl
         asl
         and #%11000000
	 clc
	 adc $fd
         sta $fd
	 php

         lda savey
         lsr
         lsr
         lsr
         lsr
         lsr
         and #%00000111
         plp
         adc $fe
         sta $fe

         ; work out int (x/8)*8
         lda savex
         and #%11111000
         clc
         adc $fd
         sta $fd
         lda $fe
         adc #0
         sta $fe

         ; storing (y and 7)
         lda savey
         and #7
	 ora $fd
         sta $fd

         ; add base of screen to address
	 ; screen is at $A000-$BFFF
         lda $fe
         ora #%10100000
         and #%10111111
         sta $fe

	 rts

unplotpixel:
         ; use $fd and $fe as 16-bit
         ; pointer.

         stx savex
         sty savey

	 jsr calculatepixeladdr

	 lda #$36
	 sta $01

         ; work out bit of byte to unset
         lda savex
         and #7
         tax
         lda bits,x
         ; set bit in byte
	 eor #$ff
         ldy #0
         and ($fd),y
         sta ($fd),y

	 lda #$37
	 sta $01

         ldx savex
         ldy savey

         rts



savea:   .byte $00
savex:   .byte $00
savey:   .byte $00

bits:
         .byte %10000000
         .byte %01000000
         .byte %00100000
         .byte %00010000
         .byte %00001000
         .byte %00000100
         .byte %00000010
         .byte %00000001


bitmapmode:

	; Reset to normal VIC-II video mode
	LDA #$a8
	sta $D054
	lda #$0
	sta $D031
	lda #40
	sta $d058

	; Enable bitmap mode
         lda #$3b
         sta $d011
	; bitmap is at $2000 + bank address
         lda #25
         sta $d018
	; bank is $8000-$BFFF
	 lda $dd00
	 and #$fc
	 ora #$01
	 sta $dd00
	; Set screen ram back to $0400-$07FF
	 lda #<$0400
	 sta $d060
	 lda #>$0400
	 sta $d061
	 lda #$00
	 sta $d062
	 sta $d063
	 
         rts

clearcolour:

         ; clear colour memory
         lda #<$0400
         sta $fd
         lda #>$0400
         sta $fe
         ldy #0
         ; white pixels, black backgnd
cl4:      lda #$10
cl3:      sta ($fd),y
         iny
         bne cl3
         inc $fe
         lda $fe
         cmp #>$0800
         bne cl4

clearscreen:

	lda #>dmalist
	sta $d701
	lda #0
	sta $d702
	sta $d704
	lda #<dmalist
	sta $d705

         rts

dmalist:
		; MEGA65 Enhanced DMA options
		.byte $0A  ; Request format is F018A
		.byte $81,$00 ; Destination is in 1st MB
		.byte $00  ; No more options
		; copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
		; F018A DMA list
		; (MB offsets get set in routine)
		.byte $03 ; fill + last request in chain
		.word 8000 ; size of copy is 8000 bytes
		.byte $00,$00,$00 ; starting at $4000
		.word $A000 ; destination address is $A000
		.byte $00   ; of bank $0
		.word $0000 ; modulo (unused)


samplelo:    .byte 0
samplehi:    .byte 0

.space previoussamples 256
.space previoussamples2 256


        .outfile "bin/scope.prg"

